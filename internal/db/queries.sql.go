// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAthlete = `-- name: CreateAthlete :one
INSERT INTO athlete (coach_id, name, email, tz)
VALUES ($1, $2, $3, $4)
RETURNING id, coach_id, name, email, tz, strava_athlete_id, strava_access_token, strava_refresh_token, strava_token_expiry, created_at, last_strava_sync
`

type CreateAthleteParams struct {
	CoachID uuid.UUID
	Name    string
	Email   pgtype.Text
	Tz      string
}

func (q *Queries) CreateAthlete(ctx context.Context, arg CreateAthleteParams) (Athlete, error) {
	row := q.db.QueryRow(ctx, createAthlete,
		arg.CoachID,
		arg.Name,
		arg.Email,
		arg.Tz,
	)
	var i Athlete
	err := row.Scan(
		&i.ID,
		&i.CoachID,
		&i.Name,
		&i.Email,
		&i.Tz,
		&i.StravaAthleteID,
		&i.StravaAccessToken,
		&i.StravaRefreshToken,
		&i.StravaTokenExpiry,
		&i.CreatedAt,
		&i.LastStravaSync,
	)
	return i, err
}

const createCoach = `-- name: CreateCoach :one
INSERT INTO coach (email, name, tz)
VALUES ($1, $2, $3)
RETURNING id, email, name, tz, created_at
`

type CreateCoachParams struct {
	Email string
	Name  pgtype.Text
	Tz    string
}

func (q *Queries) CreateCoach(ctx context.Context, arg CreateCoachParams) (Coach, error) {
	row := q.db.QueryRow(ctx, createCoach, arg.Email, arg.Name, arg.Tz)
	var i Coach
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Tz,
		&i.CreatedAt,
	)
	return i, err
}

const getAthlete = `-- name: GetAthlete :one
SELECT id, coach_id, name, email, tz, strava_athlete_id, strava_access_token, strava_refresh_token, strava_token_expiry, created_at, last_strava_sync FROM athlete WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAthlete(ctx context.Context, id uuid.UUID) (Athlete, error) {
	row := q.db.QueryRow(ctx, getAthlete, id)
	var i Athlete
	err := row.Scan(
		&i.ID,
		&i.CoachID,
		&i.Name,
		&i.Email,
		&i.Tz,
		&i.StravaAthleteID,
		&i.StravaAccessToken,
		&i.StravaRefreshToken,
		&i.StravaTokenExpiry,
		&i.CreatedAt,
		&i.LastStravaSync,
	)
	return i, err
}

const getCoachByEmail = `-- name: GetCoachByEmail :one
SELECT id, email, name, tz, created_at FROM coach WHERE email = $1 LIMIT 1
`

func (q *Queries) GetCoachByEmail(ctx context.Context, email string) (Coach, error) {
	row := q.db.QueryRow(ctx, getCoachByEmail, email)
	var i Coach
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Tz,
		&i.CreatedAt,
	)
	return i, err
}

const listAthletesByCoach = `-- name: ListAthletesByCoach :many
SELECT id, coach_id, name, email, tz, strava_athlete_id, strava_access_token, strava_refresh_token, strava_token_expiry, created_at, last_strava_sync FROM athlete WHERE coach_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListAthletesByCoach(ctx context.Context, coachID uuid.UUID) ([]Athlete, error) {
	rows, err := q.db.Query(ctx, listAthletesByCoach, coachID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Athlete
	for rows.Next() {
		var i Athlete
		if err := rows.Scan(
			&i.ID,
			&i.CoachID,
			&i.Name,
			&i.Email,
			&i.Tz,
			&i.StravaAthleteID,
			&i.StravaAccessToken,
			&i.StravaRefreshToken,
			&i.StravaTokenExpiry,
			&i.CreatedAt,
			&i.LastStravaSync,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAthleteStravaTokens = `-- name: SetAthleteStravaTokens :exec
UPDATE athlete
SET strava_athlete_id = $2,
    strava_access_token = $3,
    strava_refresh_token = $4,
    strava_token_expiry = $5
WHERE id = $1
`

type SetAthleteStravaTokensParams struct {
	ID                 uuid.UUID
	StravaAthleteID    pgtype.Int8
	StravaAccessToken  pgtype.Text
	StravaRefreshToken pgtype.Text
	StravaTokenExpiry  pgtype.Timestamptz
}

func (q *Queries) SetAthleteStravaTokens(ctx context.Context, arg SetAthleteStravaTokensParams) error {
	_, err := q.db.Exec(ctx, setAthleteStravaTokens,
		arg.ID,
		arg.StravaAthleteID,
		arg.StravaAccessToken,
		arg.StravaRefreshToken,
		arg.StravaTokenExpiry,
	)
	return err
}

const updateAthleteLastStravaSync = `-- name: UpdateAthleteLastStravaSync :exec
UPDATE athlete
SET last_strava_sync = $2
WHERE id = $1
`

type UpdateAthleteLastStravaSyncParams struct {
	ID             uuid.UUID
	LastStravaSync pgtype.Timestamptz
}

func (q *Queries) UpdateAthleteLastStravaSync(ctx context.Context, arg UpdateAthleteLastStravaSyncParams) error {
	_, err := q.db.Exec(ctx, updateAthleteLastStravaSync, arg.ID, arg.LastStravaSync)
	return err
}

const updateAthleteStravaTokens = `-- name: UpdateAthleteStravaTokens :exec
UPDATE athlete
SET strava_access_token = $2,
    strava_refresh_token = $3,
    strava_token_expiry = $4
WHERE id = $1
`

type UpdateAthleteStravaTokensParams struct {
	ID                 uuid.UUID
	StravaAccessToken  pgtype.Text
	StravaRefreshToken pgtype.Text
	StravaTokenExpiry  pgtype.Timestamptz
}

func (q *Queries) UpdateAthleteStravaTokens(ctx context.Context, arg UpdateAthleteStravaTokensParams) error {
	_, err := q.db.Exec(ctx, updateAthleteStravaTokens,
		arg.ID,
		arg.StravaAccessToken,
		arg.StravaRefreshToken,
		arg.StravaTokenExpiry,
	)
	return err
}

const upsertCoachByEmail = `-- name: UpsertCoachByEmail :one
INSERT INTO coach (email, name, tz)
VALUES ($1, $2, $3)
ON CONFLICT (email)
DO UPDATE SET name = COALESCE(EXCLUDED.name, coach.name)
RETURNING id, email, name, tz, created_at
`

type UpsertCoachByEmailParams struct {
	Email string
	Name  pgtype.Text
	Tz    string
}

func (q *Queries) UpsertCoachByEmail(ctx context.Context, arg UpsertCoachByEmailParams) (Coach, error) {
	row := q.db.QueryRow(ctx, upsertCoachByEmail, arg.Email, arg.Name, arg.Tz)
	var i Coach
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Tz,
		&i.CreatedAt,
	)
	return i, err
}

const upsertWorkout = `-- name: UpsertWorkout :exec
INSERT INTO workout (
    athlete_id, source, source_id, name, sport, started_at,
    duration_sec, distance_m, elev_gain_m, avg_hr, raw_json
) VALUES ($1, 'strava', $2, $3, $4, $5, $6, $7, $8, $9, $10)
    ON CONFLICT (athlete_id, source, source_id) DO UPDATE
SET name = $3, sport=$4, started_at=$5,
    duration_sec=$6, distance_m=$7, elev_gain_m=$8, avg_hr=$9,
    raw_json=$10, updated_at=now()
`

type UpsertWorkoutParams struct {
	AthleteID   uuid.UUID
	SourceID    int64
	Name        pgtype.Text
	Sport       string
	StartedAt   pgtype.Timestamptz
	DurationSec int32
	DistanceM   pgtype.Float8
	ElevGainM   pgtype.Float8
	AvgHr       pgtype.Int4
	RawJson     []byte
}

func (q *Queries) UpsertWorkout(ctx context.Context, arg UpsertWorkoutParams) error {
	_, err := q.db.Exec(ctx, upsertWorkout,
		arg.AthleteID,
		arg.SourceID,
		arg.Name,
		arg.Sport,
		arg.StartedAt,
		arg.DurationSec,
		arg.DistanceM,
		arg.ElevGainM,
		arg.AvgHr,
		arg.RawJson,
	)
	return err
}
